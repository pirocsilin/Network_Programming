<!DOCTYPE html>
<html lang="en">

<head>

  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="">
  <meta name="author" content="do.sibsutis.ru">

  <title>ТЕМА 3. Конспект лекций</title>
	
	<link rel="icon" type="image/png" href="../lib/css/favicon.png">
  <!-- Bootstrap Core CSS -->
  <link href="../lib/css/bootstrap.css" rel="stylesheet">
	
  <!-- Custom CSS -->
  <link href="../lib/css/scrolling-nav.css" rel="stylesheet">

  <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
  <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
  <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
    <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
  <![endif]-->
</head>

<!-- The #page-top ID is part of the scrolling feature - the data-spy and data-target are part of the built-in Bootstrap scrollspy function -->

<body id="page-top" data-spy="scroll" data-target=".navbar-fixed-top">
  <!-- Navigation -->
<nav class="navbar navbar-default navbar-fixed-top">
 <div class="container">
  <!-- Brand and toggle get grouped for better mobile display -->
  <div class="navbar-header">
   <li class="hidden"> <a class="page-scroll" href="#page-top"></a> </li>
	 
	 <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
    <span class="icon-bar"></span>
    <span class="icon-bar"></span>
    <span class="icon-bar"></span>
   </button>
	 
   <a class="navbar-brand " href="../index.htm"> 
  <text class = "hidden-xs">Сетевое программирование</text> 
  <text class = "visible-xs">СП</text>
	 </a>
  </div>

  <!-- Collect the nav links, forms, and glyphicon glyphicon-list-alt content for toggling -->
  <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
   
	 <!-- <ul class="nav navbar-nav">
		<li><a href="#"></a></li> 
   </ul> -->
	
   <ul class="nav navbar-nav navbar-right">
    <li class="dropdown">
		<button type="button" class="navbar-toggle dropdown-toggle hidden-xs" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">
			<span class="icon-bar"></span>
			<span class="icon-bar"></span>
			<span class="icon-bar"></span>
		</button>	   
		<a class = "dropdown-toggle visible-xs" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Материалы</a>
     <ul class="dropdown-menu">
<li><a href="../index.htm">Аннотация курса</a></li>

      <li role="separator" class="divider"></li>
    
  <li><a href="lec_index.htm">Теория</a></li>
   
   <li><a href="c_work.htm">Курсовая работа</a></li>
 
<li><a href="labs.htm">Лабораторные работы</a></li> 
    <li role="separator" class="divider"></li>
  
    
    <li><a href="lit.htm">Литература</a></li>
 
      <!--li><a href="q.htm">Вопросы для самопроверки</a></li-->			
     </ul>
 </li>
 </ul>
  </div><!-- /.navbar-collapse -->
 </div><!-- /.container-fluid -->
</nav>


  <div id="intro" class="section content-section ">
    <div class="container">
       <div class="row">
        <div class="col-lg-12">	


<!-- содержание -->	
<div class="page-header">				
<h3><a href="#">ТЕМА 3. ПРОТОКОЛЫ НИЖНЕГО УРОВНЯ</a></h3>
<a href="#1" class=punkt>3.1. Протоколы физического уровня </a><br>
<a href="#2" class=punkt>3.2. Пpотокол инфоpмационного канала BSC</a><br>
<a href="#3" class=punkt>3.3. Протокол Modbus RTU </a><br>
<a href="#4" class=punkt>3.4. Протокол Ethernet управления информационным каналом. Стандарт IEEE 802.3</a><br>

</div>
<!--начало-->
<a name=1 class="anchor"></a>
<h3>3.1. Протоколы физического уровня</h3>
<p><b><i>3.1.1 Интерфейсы RS-232С</i></b></p>
<p>Интерфейсы RS-232С, RS-422 и RS-485 разработаны Ассоциацией электронной промышленности (EIA - Electronics Industries Association) и Ассоциацией промышленности средств связи (TIA - Telecommunications Industry Associastion). EIA традиционно маркировала все свои стандарты префиксом "RS" (Рекомендованный стандарт).</p>
<p>Широко используемый последовательный интерфейс синхронной и асинхронной передачи данных, определяемый стандартом EIA RS-232C и рекомендациями V.24 CCITT, изначально создавался для связи компьютера с терминалом. В настоящее время используется в самых различных применениях.</p>
<p>Интерфейс RS-232C соединяет два устройства. Линия передачи первого устройства соединяется с линией приема второго и наоборот (полный дуплекс) Для управления соединенными устройствами используется программное подтверждение (введение в поток передаваемых данных соответствующих управляющих символов). Возможна организация аппаратного подтверждения путем организации дополнительных RS-232 линий для обеспечения функций определения статуса и управления.</p>
<p>В компьютере интерфейс RS-232C реализован в двух исполнениях – 9-ти контактном и 25 – контактном (рис.3.1а и рис.3.1б, соответственно).</p>
<p><img src="img/image004.gif"></p>
<p>Рис. 3.1. Варианты реализации разъемов RS-232С. </p>
<br>
<p>Таблица 3.1. </p>
<p><img src="img/image005.gif"></p>
<br>
<p>Интерфейс RS-232C предназначен для подключения к компьютеру стандартных внешних устройств (принтера, сканера, модема, мыши и др.), а также для связи компьютеров между собой. Основными преимуществами использования RS-232C по сравнению с Centronics являются возможность передачи на значительно большие расстояния и гораздо более простой соединительный кабель. В то же время работать с ним несколько сложнее. Данные в RS-232C передаются в последовательном коде побайтно. Каждый байт обрамляется стартовым и стоповыми битами. Данные могут передаваться как в одну, так и в другую сторону (дуплексный режим).</p>
<p>Назначения сигналов следующие:</p>
<p class=punkt><b>FG</b> – защитное заземление (экран).</p>
<p class=punkt><b>TxD</b> – данные, передаваемые компьютером в последовательном коде (логика отрицательная).</p>
<p class=punkt><b>RxD</b> – данные, принимаемые компьютером в последовательном коде (логика отрицательная).</p>
<p class=punkt><b>RTS</b> – сигнал запроса передачи. Активен во все время передачи.</p>
<p class=punkt><b>CTS</b> – сигнал сброса (очистки) для передачи. Активен во все время передачи. Говорит о готовности приемника.</p>
<p class=punkt><b>DSR</b> – готовность данных. Используется для задания режима модема.</p>
<p class=punkt><b>SG</b> – сигнальное заземление, нулевой провод.</p>
<p class=punkt><b>DCD</b> – обнаружение несущей данных (детектирование принимаемого сигнала).</p>
<p class=punkt><b>DTR</b> – готовность выходных данных.</p>
<p class=punkt><b>RI</b> – индикатор вызова. Говорит о приеме модемом сигнала вызова по телефонной сети.
</p>
<p>Наиболее часто используются трех - или четырехпроводная связь (для двунаправленной передачи). Схема соединения для четырехпроводной линии связи показана на рисунке 3.2.</p>
<p><img src="img/image006.gif"></p>
<p>Рис.3.2. Схема 4-проводной линии связи для RS-232C</p>
<br>
<p>Для двухпроводной линии связи в случае только передачи из компьютера во внешнее устройство используются сигналы SG и TxD. Все 10 сигналов интерфейса задействуются только при соединении компьютера с модемом.</p>
<p>Формат передаваемых данных показан на рисунке 3.3. Собственно данные (5, 6, 7 или 8 бит) сопровождаются стартовым битом, битом четности и одним или двумя стоповыми битами. Получив стартовый бит, приемник выбирает из линии биты данных через определенные интервалы времени. Очень важно, чтобы тактовые частоты приемника и передатчика были одинаковыми (допустимое расхождение - не более 10%). Скорость передачи по RS-232C может выбираться из ряда: 110, 150, 300, 600, 1200, 2400, 4800, 9600, 19200, 38400, 57600, 115200 бит/с.</p>
<p>Все сигналы RS-232C передаются специально выбранными уровнями, обеспечивающими высокую помехоустойчивость связи (рис.3.4.). Отметим, что данные передаются в инверсном коде (логической единице соответствует низкий уровень, логическому нулю - высокий уровень).</p>
<p><img src="img/image007.gif"></p>
<p>Рис.3.3 Формат данных RS-232C</p>
<br>
<p><img src="img/image008.gif"></p>
<p>Рис.3.4 Уровни сигналов RS-232C на передающем и принимающем концах линии связи.</p>
<br>
<p><b><i>3.1.2 Интерфейсы RS-422 и RS-485</i></b></p>
<p>Интерфейс RS-232C обеспечивает сопряжение между узлами сети по принципу точка-точка. В промышленных сетях сбора технологической информации и управления технологическими объектами требуются многоточечные соединения. Для их реализации используются интерфейсы RS-422 и RS-485.</p>
<p>Стандарты RS-485 и RS-422 имеют много общего. RS-485, определяющий двунаправленную полудуплексную передачу данных, является единственным стандартом EIA/TIA, допускающим множественные приемники и драйверы в шинных конфигурациях. EIA/TIA-422, с другой стороны, определяет единственный однонаправленный драйвер с множественными приемниками. Элементы RS-485 обратно совместимы и взаимозаменяемы со своими двойниками из RS-422, однако драйверы RS-422 не должны использоваться в системах на основе RS-485, поскольку они не могут отказаться от управления шиной. </p>
<p>Дифференциальная передача сигнала в системах на основе RS-485 и RS-422 обеспечивает надежную передачу данных в присутствии шумов, а дифференциальные входы их приемников кроме того могут подавлять значительные синфазные напряжения. Однако для защиты от значительно больших уровней напряжений, которые обычно ассоциируются с электростатическим разрядом (ESD), необходимо принимать дополнительные меры. </p>
<p><b><i>3.1.3. Управление передачей</i></b></p>
<p>Управление передачей в интерфейсах RS-232C, RS-485 и RS-422 выполняется по одинаковым принципам и алгоритмам. Поэтому остановимся на рассмотрении управления обменом интерфейса RS-232C. Обмен по RS-232C осуществляется с помощью обращений к специально выделенным для этого портам COM1 (адреса 3F8h...3FFh, прерывание IRQ4), COM2 (адреса 2F8h...2FFh, прерывание IRQ3), COM3 (адреса 3F8h...3EFh, прерывание IRQ10), COM4 (адреса 2E8h...2EFh, прерывание IRQ11). </p>
<p>Каждый COM-порт (асинхронный адаптер в ЭВМ), реализующий RS-232С, управляется 10-ю внутренними регистрами. Обращение к регистрам производится по их адресам, называемыми портами ввода/вывода. </p>
<p>Регистры данных и скорости позволяют изменять скорость передачи данных в диапазоне от 110 бод до 115200 бод. С помощью управляющего регистра устанавливаются скорость передачи данных, контроль четности и длина передаваемых символов (5, 6, 7 и 8 бит). Старт передачи одиночного символа в канал связи и момент приема по линии связи входного символа определяется по изменению содержимого регистра состояния линий.</p>
<p>RS485 обеспечивает передачу данных со скоростью до 10 Мбит/с. Максимальная дальность зависит от скорости: при скорости 10 Мбит/с максимальная длина линии — 120 м, при скорости 100 кбит/с — 1200 м.</p>
<p>Количество устройств, подключаемых к одной линии интерфейса, зависит от типа примененных в устройстве приемопередатчиков. Один передатчик рассчитан на управление 32 стандартными приемниками. Выпускаются приемники со входным сопротивлением 1/2, 1/4, 1/8 от стандартного. При использовании таких приемников общее число устройств может быть увеличено соответственно: 64, 128 или 256.</p>
<p>Стандарт не нормирует формат информационных кадров и протокол обмена. Наиболее часто для передачи байтов данных используются те же фреймы, что и в интерфейсе RS232: стартовый бит, биты данных, бит паритета, стоповый бит. </p>
<p>Протоколы обмена в большинстве систем работают по принципу "ведущий" - "ведомый". Одно устройство на магистрали является ведущим (master) и инициирует обмен посылкой запросов подчиненным устройствам (slave), которые различаются логическими адресами.</p>
<p>Современные пользовательские ЭВМ  в отличие от промышленных ЭВМ не комплектуются разъемами COM-порта. Поэтому при применении таких ЭВМ в промышленных сетях сбора и управления используется USB-интерфейс.   Программирование USB-интерфейса выполняется такими же процедурами как в интерфейсах RS-232C, RS-485 и RS-422. Для перехода от USB-интерфейса к интерфейсам  RS-485 и RS-422 используется специальный адаптер – преобразователь интерфейсов AC4 предназначенный для взаимного преобразования сигналов интерфейсов USB и RS485. АС4 позволяет подключать к промышленной информационной сети на базе RS485 персональный компьютер, имеющий USB-порт. Структура такой сети на примере съема значений температуры бетона и управления нагревом бетона при зимнем бетонировании показана на рис.3.5.</p>
<p><img src="img/image009.gif"></p>
<p>Рис.3.5. Структурная схема промышленной сети на RS485</p>
<br>
<p>Программа управления информационным каналом в сети на ПК выполняет «первичные» (управляющие) функции, а на вычислительных устройствах в технологической цепи  «вторичные» (управляемые) функции. Информация от управляющей машины называется командами, а от управляемых – ответами. </p>
<p>ПК (управляющая) управляет звеном передачи данных (каналом). Эта станция передает кадры команд вторичным станциям и получает кадры ответа от этих станций. Если канал является многоточечным, главная станция отвечает за поддержку отдельного сеанса связи с каждой станцией, подключенной к каналу. </p>
<p>Вторичные станции (управляемые) работают как зависимые по отношению к первичной станции (ведущей). Они реагирует на команды, получаемые от первичной станции, в виде ответов и поддерживают только один сеанс, а именно только с первичной станцией.</p>
<br>
<a name=2 class="anchor"></a>
<h3>3.2. Пpотокол инфоpмационного канала BSC</h3>
<p><b><i>3.2.1 Упpавление инфоpмационным каналом в BSC</i></b></p>
<p>Родоначальниками большинства канальных протоколов в различных сетях стали байт-ориентированный протокол BSC и бит-ориентированный протокол HDLC. Особенно популярны разновидности HDLC. К таким протоколам можно отнести канальные протоколы XМodem для модемной связи, протоколы IEEE 802.Х, протокол LAPB для сетей Х.25 и др. </p>
<p>Байт-ориентированный протокол BSC (Binary Synchronous Communication) разработан фирмой IBM в середине 60-х годов. Протокол BSC – кодозависимый протокол, то есть использует для управления обменом набор управляющих символов. Каждый переданный символ анализируется на приемной стороне, чтобы определить, является ли он управляющим символом или относится к массиву данных.</p>
<p>Управляющие символы, применяемые в BSC, представлены кодом ASCII. Приведем основные из управляющих символов и их код в HEX-коде:</p>
<p class=punkt>SYN(код 16h) – синхронизирующий символ</p>
<p class=punkt>SOH(код 01h) – начало заголовка пакета</p>
<p class=punkt>STX(код 02h) – начало текста</p>
<p class=punkt>ETX(код 034) – конец текста</p>
<p class=punkt>ETB(код 17h) – конец передачи блока (заголовка)</p>
<p class=punkt>ENQ(код 05h) – запрос</p>
<p class=punkt>ACK(код 06h) – подтверждение</p>
<p class=punkt>NAK(15h) – отрицательная квитанция (переспрос)</p>
<p class=punkt>EOT(04h) – конец сеанса связи</p>
<p>Протокол обеспечивает передачу двух типов кадров: управляющих и информационных. В управляющих кадрах передаются управляющие и служебные символы, в информационных - сообщения (отдельные пакеты, последовательность пакетов). </p>
<p>Работа протокола BSC осуществляется в три фазы: </p>
<ul>
<li>	установление соединения с помощью передачи символа ENQ; </li>
<li>	поддержание сеанса передачи сообщений; </li>
<li>	разрыв соединения с помощью передачи символа EOT.</li>
</ul>
<p>Протокол требует на каждый переданный кадр посылки квитанции(символ ACK или NAK) о результате его приема. Кадры, переданные с ошибкой, передаются повторно. Протокол определяет максимальное число повторных передач.</p>
<p>Передача последующего кадра возможна только тогда, когда получена положительная квитанция на прием предыдущего. Это существенно ограничивает быстродействие протокола и предъявляет высокие требования к качеству канала связи.</p>
<p>Так как при синхронной передаче нет стоповых и стартовых битов, отделяющих байты друг от друга, синхронизация достигается за счет того, что передатчик добавляет два или более управляющих символа, называемых символами SYN, перед каждым блоком символов. В коде ASCII символ SYN имеет двоичное значение 0010110, это несимметричное относительно начала символа значение позволяет легко разграничивать отдельные символы SYN при их последовательном приеме. Символы SYN выполняют две функции: во-первых, они обеспечивают приемнику побитную синхронизацию, во-вторых, как только битовая синхронизация достигается, они позволяют приемнику начать распознавание границ символов SYN. После того как приемник начал отделять один символ от другого, можно задавать границы начала кадра с помощью другого специального символа. Обычно в символьных протоколах для этих целей используется символ STX (Start of TeXt, ASCII 0000010). Другой символ отмечает окончание кадра – ЕТХ (End of TeXt, ASCII 0000011).</p>
<p><b>Режимы прозрачности</b></p>
<p>Способ выделения начала и конца кадра по специальным символам работает корректно только в том случае, если внутри кадра нет символов коды которых соответствуют кодам управляющих символов, например, STX и ЕТХ. Появление внутри кадра символа ETX может привести к ложному определению конца кадра. Например, при передаче с компьютера на компьютер программы, данные внутри кадра могут быть любые. Для устранения подобных ложных определений протокол BSC может работать в двух режимах - непрозрачном, в котором некоторые специальные символы внутри кадра запрещались, и прозрачном, в котором разрешалась передачи внутри кадра любых символов, в том числе и ЕТХ. Прозрачность достигалась за счет того, что перед управляющими символами всегда вставляется символ DLE (Data Link Escape). Такая процедура называется байтстаффингом (stuffing – заполнять). Символ DLE должен был предварять служебный символ. В случае если в поле данных кадра встречался символ с кодом DLE , то передатчик удваивал символ DLE, то есть порождал последовательность DLE DLE. Приемник, встретив подряд два символа DLE DLE, всегда удалял первый, но оставшийся DLE уже не рассматривал как начало управляющей последовательности. То есть, если в передаваемых данных встречалась последовательность DLE ЕТХ, она переделывалась передатчиком в DLE DLE ЕТХ, а на приемной стороне после исключения одного DLE ЕТХ оставшиеся символы DLE ЕТХ считались просто пользовательскими данными.</p>
<p>Запрос на обмен осуществляется посылкой последовательности DLE SOH. Получив положительную квитанцию DLE ACK, передающая сторона начинает передачу кадров. Сначала передается управляющий кадр, имеющий формат, показанный на рис.3.6а, затем после приема положительной квитанции DLE ACK передается кадр данных (рис.3.6б).</p>
<p><img src="img/image010.gif"></p>
<p>Рис.3.6. Форматы кадров BSC</p>
<br>
<p>Если данные передаются группой кадров, каждый из них завершается последовательностью DLE ЕТB, а последний последовательностью DLE ЕТХ. Байты BCC1 и BCC2 являются байтами контрольной суммы. Для завершения сеанса связи передается последовательность DLE EOT.</p>
<p>Пример процедуры передачи сообщения между двумя ЭВМ по протоколу BSC представлен на рис.3.7.</p>
<p><img src="img/image011.gif"></p>
<p>Рис.3.7. Процедура передачи сообщения</p>
<br>
<a name=3 class="anchor"></a>
<h3>3.3. Протокол Modbus RTU </h3>
<p>Самым распространенным в мире в промышленных сетях является протокол Modbus RTU  и сеть Modbus. Популярность протокола в настоящее время объясняется, прежде всего, совместимостью с большим количеством оборудования, которое имеет встроенный протокол Modbus. Кроме того, Modbus обладает высокой достоверностью передачи данных, связанную с применением надежного метода контроля ошибок. Modbus позволяет унифицировать команды обмена благодаря стандартизации номеров (адресов) регистров и функций их чтения-записи.</p>
<p>Основным недостатком Modbus является сетевой обмен по типу "ведущий/ведомый", что не позволяет ведомым устройствам передавать данные по мере их появления и поэтому требует интенсивного опроса ведомых устройств ведущим.</p>
<p>Стандарт Modbus устанавливает последовательный протокол обмена данными между одним ведущим (контроллером или компьютером) и несколькими ведомыми (обычно модулями ввода-вывода) устройствами. Ведущее устройство выполняет роль клиента (т.е. выдает запрос серверу), а ведомое выполняет роль сервера (поставляет данные в ответ на запрос).  </p>
<p>Протокол Modbus имеет два режима передачи: режим RTU (Remote Terminal Unit – «удаленное терминальное устройство») и режим ASCII. Стандарт  предусматривает, что режим RTU в протоколе Modbus должен присутствовать обязательно, а режим ASCII является опционным. Пользователь может  выбирать необходимый ему режим, но все модули, включенные в сеть Modbus, должны иметь один и тот же режим передачи.</p>
<p>Распространенность протокола Modbus RTU объясняется, прежде всего, совместимостью с большим количеством популярного в России оборудования,  которое уже имеет протокол Modbus RTU. Кроме того, он имеет высокую достоверностью передачи данных, которая обусловлена применением надежного метода контроля ошибок передачи. Протокол позволяет унифицировать команды обмена благодаря стандартизации номеров (адресов) регистров и функций  их чтения-записи. Режим RTU имеет также большую информационную пропускную способность, чем режим ASCII при той же скорости передачи битов.</p>
<p>Стандарт Modbus предусматривает применение физического интерфейса RS485 или RS232.</p>
<p>Модель OSI протокола Modbus содержит три уровня: физический, канальный и прикладной.</p><br>
<p>Табл.2.2. Модель OSI для Modbus</p>
<div class="row">
<div class="col-lg-7">
<table class="table table-hover table-condensed table-striped">
 
<tr>
 <td width=50 rowspan=1 valign=top>
<p><b>Номер уровня</b></p>
 </td>
 
<td width=200 colspan=1 valign=top>
 <p><b>Название уровня</b></p>
 </td>

<td width=200 colspan=1 valign=top>
 <p><b>Реализация</b></p>
 </td>

</tr>
 
<tr>
 <td width=50 rowspan=1 valign=top>
<p>7</p>
 </td>
 
<td width=200 colspan=1 valign=top>
 <p>Прикладной</p>
 </td>

<td width=200 colspan=1 valign=top>
 <p>MODBUS Application Protocol</p>
 </td>

</tr>
 
<tr>
 <td width=50 rowspan=1 valign=top>
<p>6</p>
 </td>
 
<td width=200 colspan=1 valign=top>
 <p>Уровень представления</p>
 </td>

<td width=200 colspan=1 valign=top>
 <p>Нет</p>
 </td>

</tr>

<tr>
 <td width=50 rowspan=1 valign=top>
<p>5</p>
 </td>
 
<td width=200 colspan=1 valign=top>
 <p>Сеансовый</p>
 </td>

<td width=200 colspan=1 valign=top>
 <p>Нет</p>
 </td>

</tr>

<tr>
 <td width=50 rowspan=1 valign=top>
<p>4</p>
 </td>
 
<td width=200 colspan=1 valign=top>
 <p>Транспортный</p>
 </td>

<td width=200 colspan=1 valign=top>
 <p>Нет</p>
 </td>

</tr>

<tr>
 <td width=50 rowspan=1 valign=top>
<p>3</p>
 </td>
 
<td width=200 colspan=1 valign=top>
 <p>Сетевой</p>
 </td>

<td width=200 colspan=1 valign=top>
 <p>Нет</p>
 </td>

</tr>

<tr>
 <td width=50 rowspan=1 valign=top>
<p>2</p>
 </td>
 
<td width=200 colspan=1 valign=top>
 <p>Канальный</p>
 </td>

<td width=200 colspan=1 valign=top>
 <p>Протокол  "Ведущий.ведомый"<br>
Режимы RTU  и ASCII</p>
 </td>

</tr>

<tr>
 <td width=50 rowspan=1 valign=top>
<p>1</p>
 </td>
 
<td width=200 colspan=1 valign=top>
 <p>Физический</p>
 </td>

<td width=200 colspan=1 valign=top>
 <p>RS485 или RS232</p>
 </td>

</tr>


</table></div></div>

<br>
<p>Протокол Modbus предполагает, что только одно ведущее устройство (контроллер) и до 247 ведомых (модулей ввода-вывода) могут быть объединены в промышленную сеть. Обмен данными всегда инициируется ведущим устройством. Ведомые устройства никогда не начинают передачу данных, пока не получат  запрос от ведущего. Ведомые устройства  также не могут обмениваться данными друг с другом. Поэтому в любой момент времени в сети Modbus может происходить только один акт обмена. Адреса с 1 по 247 являются адресами протокола устройств в сети. Адреса с 248 по 255 являются зарезервированными. В сети не должно быть устройств с одинаковыми адресами.</p>
<p>В протоколе Modbus RTU сообщение начинает восприниматься как новое после паузы (тишины) на шине длительностью не менее 3,5 символов (14 бит),  т.е. величина паузы в секундах будет различной в зависимости от скорости передачи. Формат кадра показан на рисунке 2.9.</p>
<p><img src="img/image012.gif"></p>
<p>Рис.3.8. Формат кадра протокола Modbus RTU</p>
<br>
<p>Поле «Адрес» всегда содержит только адрес ведомого устройства, даже в ответах на команду, посланную ведущим устройством. Благодаря этому ведущее устройство знает, от какого модуля пришел ответ.</p>
<p>Поле «Код функции» говорит модулю о том, какое действие нужно выполнить. Примеры кодов функций протокола Modbus RTU: </p>
<p class=punkt>•	чтение дискретного вывода –  0x01</p>
<p class=punkt>•	чтение дискретного ввода –  0x02</p>
<p class=punkt>•	чтение аналогового вывода –  0x03</p>
<p class=punkt>•	чтение аналогового ввода –  0x04</p>
<p class=punkt>•	запись дискретного вывода –  0x05</p>
<p class=punkt>•	запись аналогового вывода –  0x06</p>
<p class=punkt>•	запись нескольких дискретных выводов –  0x0F</p>
<p class=punkt>•	запись нескольких аналоговых выводов –  0x10.</p>
<p>Подробный список команд можно посмотреть в формате pdf в [<a href="https://ipc2u.ru/articles/prostye-resheniya/modbus-rtu/" target="_balnk">https://ipc2u.ru/articles/prostye-resheniya/modbus-rtu/</a>  Просто о Modbus RTU с подробным описанием и примерами].</p>
<p>Поле «Данные» может содержать произвольное количество байт. В нем может содержаться информация о параметрах, используемых в запросах контроллера или ответах модуля. </p>
<p>Например, если код функции указывает, что необходимо считать данные из группы регистров устройства ввода (код функции 03 hex), то поле данных содержит адрес начального регистра и количество регистров. Если ведущее устройство посылает команду записи данных в группу регистров (код функции 10 hex), то поле данных должно  содержать адрес начального регистра, количество регистров, количество байтов данных и данные для записи в регистр. Конкретное содержание поля данных устанавливается стандартом для каждой функции отдельно.</p>
<p>Поле «Контрольная сумма» содержит контрольную сумму длиной 2 байта. Контрольная сумма — некоторое значение, рассчитанное по набору данных путём применения определённого алгоритма и используемое для проверки целостности данных при их передаче или хранении. </p>
<p>В протоколе Modbus RTU используется алгоритм вычисления контрольной суммы CRC16.</p>
<p>CRC (Cyclic Redundancy Code – «Циклический избыточный код») – алгоритм расчёта контрольной суммы для передаваемого сообщения, основанный на полиномиальной арифметике. </p>
<p>Основная идея алгоритма CRC состоит в том, что сообщение рассматривается как одно последовательное двоичное число, которое умножается на Х<sup>16</sup> (сдвигается влево на 16 бит), а затем делится на Х<sup>16</sup>+Х<sup>15</sup>+Х<sup>2</sup>+1, выражаемое как двоичное число (11000000000000101). Целая часть результата игнорируется, а 16-ти битный остаток (предварительно инициализированный единицами для предотвращения случая, когда все сообщение состоит из нулей) добавляется к сообщению (старшим битом вперед) как два байта контрольной суммы. Полученное сообщение, включающее CRC, затем в приемнике делится на тот же полином (Х<sup>16</sup>+Х<sup>15</sup>+Х<sup>2</sup>+1). Если ошибок не было, остаток от деления должен получится нулевым.</p>
<br>
<a name=4 class="anchor"></a>
<h3>3.4. Протокол Ethernet управления информационным каналом. Стандарт IEEE 802.3</h3>
<p>В 1980 году фирмы DEC, Intel и Xerox совместно разработали и опубликовали стандарт Ethernet версии II для сети, построенной на основе коаксиального кабеля, который стал последней версией фирменного стандарта Ethernet. </p>
<p>Все виды стандартов Ethernet (в том числе Fast Ethernet и Gigabit Ethernet) основаны на одном и том же методе использования разделяемой среды передачи данных – методе CSMA/CD (множественный доступ с проверкой несущей и обнаружением коллизий). Этот метод применяется исключительно в сетях с логической общей шиной (к которым относятся и радиосети, породившие этот метод). </p>
<p>Метод доступа CSMA/CD предполагает для передающей станции выполнения следующего алгоритма:</p>
<p class=punkt>1.	Если среда свободна, станция сразу же начинает передачу или ожидает в течение фиксированного интервал времени T. Интервал T обычно берется равным максимальному времени распространения сигнала из конца в конец; </p>
<p class=punkt>2.	Если среда занята, станция продолжает прослушивание до тех пор, пока среда не освободится, затем переходит к шагу 1; </p>
<p class=punkt>3.	Если в момент начала передачи станция обнаруживает, что другая станция тоже начала передачу, она задерживает передачу на случайный интервал времени. По окончании задержки станция возвращается к шагу 1</p>
<p class=punkt>4.	После окончания передачи кадра станция обязана выдержать технологическую паузу (Inter Packet Gap) в 9.6 мкс. Эта пауза, называемая также межкадровым интервалом, нужна для приведения сетевых адаптеров в исходное состояние, а также для предотвращения монопольного захвата среды одной станцией.</p>
<p>Кадры, передаваемые станцией, поступают на все узлы локальной сети, но только тот, кому они адресованы, принимает эти кадры и посылает подтверждение.</p>
<p>Стандарт IEEE 802.3 был разработан на основе кадра Ethernet, изменив ряд его характеристик. Стандарт IEEE 802.3 во многом совпадает со своим предшественником, но некоторые различия все же имеются. В частности, в стандарте IEEE 802.3 различаются уровни MAC и LLC. В оригинальном Ethernet оба эти уровня объединены в единый канальный уровень. Согласно стандарту IEEE 802, кадр технологии Ethernet – это кадр, формируемый уровнем MAC, в который должен вкладываться кадр уровня LLC. Форматы базового кадра Ethernet и  пакета стандарта IEEE 802.3 показаны на рисунке 3.9а и 3.9а, соответственно:</p>
<p><img src="img/image013.gif"></p>
<p>Рис. 3.9. Формат кадра Ethernet и кадра IEEE 802.3</p>
<br>
<p>Поля кадра Ethernet имеют следующие характеристики.</p>
<p><i>Преамбула</i>. Размер 8 байт. Используется для синхронизации кадра. Преамбула всегда содержит код 10101010 c чередованием единиц и нулей в первых 7-ми байтах и код 10101011 в последнем байте.</p>
<p><i>Адрес назначения</i> (DA, destination address). Размер 6 байт. Содержит MAC-адрес станции узла ЛВС, которому предназначено сообщение. Если старший 7-ой бит в первом байте равен 0 , то первые три байта задают адрес группы, а следующие 3 байта задают локальный адрес в группе. Если же старший 7-ой бит, равен 1, то кадр адресуется всем машинам какой-либо группе. Если все биты первого байта адреса, равны 1, то кадр адресуется всем машинам всех групп и называется широковещательным адресом (broadcast).</p>
<p><i>Адрес источника</i>(SA, source address). Размер 6 байт. Указывает MAC-адрес станции, которая посылает кадр. </p>
<p><i>Тип</i>. Размер 2 байта. Идентифицирует тип протокола более высокого уровня. Это позволяет, множеству протоколов высокого уровня разделят ЛВС без того, чтобы вникать в содержимое пакетов друг друга. Приведем значения в шестнадцатеричной системе этого поля для некоторых распространенных сетевых протоколов: 0x0800 для IP, 0x0806 для ARP, 0x809B для AppleTalk, 0x0600 для XNS, и 0x8137 для IPX/SPX.</p>
<p><i>Данные</i>. Это поле может иметь длину от 46 до 1500 байт и содержит данные, составляющие сообщение.</p>
<p><i>CRC</i> – контрольная последовательность размером в 4 байта. Содержит остаток избыточной циклической суммы (cyclic redundancy checksum), вычислительный с помощью полиномов типа CRC-32. </p>
<p>Если не учитывать преамбулу, то видно, что сообщение Ethernet имеет длину от 64 до 1518 байт. Минимальная длина данных равна 46 байт.</p>
<p>В стандарте IEEE 802.3 в отличие от оригинального Ethernet выделен байт <i>признака начала кадра</i> с кодом 10101011.</p>
<p>Поле <i>Тип</i> заменено на поле Длина. Для кадра IEEE 802.3 в этом поле содержится выраженный в байтах размер следующего поля - поля данных (LLC Data). Если эта цифра приводит к общей длине кадра меньше 64 байт, то за полем LLC Data добавляется поле Pad. Для протокола более высокого уровня не возникает путаницы с определением типа кадра, так как для кадра IEEE 802.3 значение этого поля не может быть больше 1500 (0x05DC).</p>
<p><i>Данные (LLC Data)</i> – поле данных, которое обрабатывается подуровнем LLC.</p>
<p><i>Набивка</i>(Pad) – в это поле вставляются пустые символы для доведения длины пакета до минимально допустимой величины.</p>
<p>Длина пакета Ethernet и IEEE 802.3 находится в диапазоне от 64 до 1518 байт. Однако в стандарте IEEE 802.3 имеется возможность передачи данных длиной менее 46 байт, т.к. на канальном уровне пакет автоматически дополняется до нужного размера.</p>



<br><br>
<!--конец-->
      
				

				</div>
			</div>
			
      </div>
    </div>
  </div>
	
	<!--Меню навигации по Темам -->	
	<div aria-label="..." class = "nav-menu">
	 <ul class="pager background-transition-slow">
		 <li title="Наверх" style = "margin-right:15px;	"><a class = "glyphicon glyphicon-menu-up page-scroll" href="#page-top"></a></li>
		 <li title="К предыдущей лекции"><a class = "glyphicon glyphicon-menu-left page-scroll" href="lec2.htm"></a></li>
		 <li title="В содержание"><a class = "glyphicon glyphicon-list-alt" href="lec_index.htm"></a></li>
		 <li title="К следующей лекции"><a class = "glyphicon glyphicon-menu-right page-scroll" href="lec4.htm"></a></li>
	 </ul>
	</div>
	<!---->
	
	</div>
  <!-- jQuery -->
  <script src="../lib/js/jquery.js"></script>

  <!-- Bootstrap Core JavaScript -->
  <script src="../lib/js/bootstrap.min.js"></script>

  <!-- Scrolling Nav JavaScript -->
  <script src="../lib/js/jquery.easing.min.js"></script>
  <script src="../lib/js/scrolling-nav.js"></script>

</body>

</html>
