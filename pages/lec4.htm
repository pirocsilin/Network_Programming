<!DOCTYPE html>
<html lang="en">

<head>

  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="">
  <meta name="author" content="do.sibsutis.ru">

  <title>ТЕМА 4. Конспект лекций</title>
	
	<link rel="icon" type="image/png" href="../lib/css/favicon.png">
  <!-- Bootstrap Core CSS -->
  <link href="../lib/css/bootstrap.css" rel="stylesheet">
	
  <!-- Custom CSS -->
  <link href="../lib/css/scrolling-nav.css" rel="stylesheet">

  <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
  <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
  <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
    <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
  <![endif]-->
</head>

<!-- The #page-top ID is part of the scrolling feature - the data-spy and data-target are part of the built-in Bootstrap scrollspy function -->

<body id="page-top" data-spy="scroll" data-target=".navbar-fixed-top">
  <!-- Navigation -->
<nav class="navbar navbar-default navbar-fixed-top">
 <div class="container">
  <!-- Brand and toggle get grouped for better mobile display -->
  <div class="navbar-header">
   <li class="hidden"> <a class="page-scroll" href="#page-top"></a> </li>
	 
	 <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
    <span class="icon-bar"></span>
    <span class="icon-bar"></span>
    <span class="icon-bar"></span>
   </button>
	 
   <a class="navbar-brand " href="../index.htm"> 
  <text class = "hidden-xs">Сетевое программирование</text> 
  <text class = "visible-xs">СП</text>
	 </a>
  </div>

  <!-- Collect the nav links, forms, and glyphicon glyphicon-list-alt content for toggling -->
  <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
   
	 <!-- <ul class="nav navbar-nav">
		<li><a href="#"></a></li> 
   </ul> -->
	
   <ul class="nav navbar-nav navbar-right">
    <li class="dropdown">
		<button type="button" class="navbar-toggle dropdown-toggle hidden-xs" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">
			<span class="icon-bar"></span>
			<span class="icon-bar"></span>
			<span class="icon-bar"></span>
		</button>	   
		<a class = "dropdown-toggle visible-xs" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Материалы</a>
     <ul class="dropdown-menu">
<li><a href="../index.htm">Аннотация курса</a></li>

      <li role="separator" class="divider"></li>
    
  <li><a href="lec_index.htm">Теория</a></li>
   
   <li><a href="c_work.htm">Курсовая работа</a></li>
 
<li><a href="labs.htm">Лабораторные работы</a></li> 
    <li role="separator" class="divider"></li>
  
    
    <li><a href="lit.htm">Литература</a></li>
 
      <!--li><a href="q.htm">Вопросы для самопроверки</a></li-->			
     </ul>
 </li>
 </ul>
  </div><!-- /.navbar-collapse -->
 </div><!-- /.container-fluid -->
</nav>


  <div id="intro" class="section content-section ">
    <div class="container">
       <div class="row">
        <div class="col-lg-12">	


<!-- содержание -->	
<div class="page-header">				
<h3><a href="#">ТЕМА 4. ПРОТОКОЛЫ СРЕДНЕГО УРОВНЯ </a></h3>
<a href="#1" class=punkt>4.1. Общие  сведения протоколов среднего уровня</a><br>
<a href="#2" class=punkt>4.2. Протоколы IPX/SPX. Протоколы локальных сетей</a><br>
<a href="#3" class=punkt>4.3. Протокол NetBIOS</a><br>
<a href="#4" class=punkt>4.4. Семейство протоколов TCP/IP</a><br> 
<a href="#5" class=punkt>4.5. Протокол UDP </a><br>
</div>
<!--начало-->
<a name=1 class="anchor"></a>
<h3>4.1. Общие  сведения протоколов среднего уровня </h3>
<p>До сих пор рассмотренные протоколы работали на самом низком уровне ЛВС. Такие протоколы имеют дело с передачей сообщений (пакетов) между компьютерами и ничего не знают о файл-серверах и перенаправлении файлов. Эти протоколы не включают никаких средств для обеспечения последовательности приёма переданных данных, а также средств для идентификации прикладных программ, нуждающихся в обмене данными. Этим занимаются протоколы среднего уровня. К протоколам среднего уровня относятся:</p>
<p class=punkt>IPX, IP – протоколы сетевого уровня,</p>
<p class=punkt>SPX, TCP – протоколы транспортного уровня,</p>
<p>Протоколы среднего уровня IPX/SPX и TCP/IP при классификации по модели OSI более всего соответствуют транспортному уровню с некоторыми характеристиками других уровней (таких, как сеансовый уровень). Эти протоколы позволяют компьютерам в ЛВС легко обмениваться данными друг с другом.</p>
<p>Независимо от внутренней конструкции каждого конкретного протокола, все они имеют определённые функции и свойства:</p>
<p class=punkt>a)	Инициализация связи. Каждый протокол имеет средства для идентификации рабочей станции по имени, номеру или по обоим этим атрибутам. Обмен информацией между определёнными узлами активизируется после идентификации узла-адресата (обычно файлового сервера) рабочей станцией, инициирующей диалог. Инициирующая станция также устанавливает один из двух типов диалога: датаграмму, в которой пакеты адресуются и передаются без гарантии и подтверждения получения, и сеанс, в котором устанавливается связь с определённой станцией и гарантируется доставка сообщений.</p>
<p class=punkt>b)	Отправка и получение данных. Каждый протокол представляет средства для отправки и получения сообщений рабочим станциям адресата и источника. Протокол накладывает определённые ограничения на длину сообщений, кроме того он предоставляет участникам диалога сеансного типа средства для определения статуса диалога. </p>
<p class=punkt>c)	Завершение обмена. Протокол предоставляет средства для вежливого завершения диалога.
</p>
<p>Ниже приводится рассмотрение протоколов IPX, SPX, TCP/IP. Данные циркулирующие в ЛВС, фактически поступают от прикладных программ или от программного обеспечения для перенаправления файлов, которые переносят запросы DOS на файловый сервер и обратно.</p>
<p><b>Датаграммы и сеансы</b></p>
<p>Существуют два типа межкомпьютерного обмена данными – датаграммы и сеансы. Датаграмма – это сообщение , которое не требует подтверждение о приёме от принимающей стороны. Если такое подтверждение необходимо , то адресат должен сам послать специальное сообщение. Для осуществления обмена этим способом принимающая и передающая стороны должны придерживаться определённого протокола во избежании недоразумений. Каждая датаграмма является самостоятельным сообщением, и при наличии нескольких датаграмм в ЛВС порядок их доставки не гарантируется. В некоторых случаях максимальный размер датаграмм гораздо меньше, чем длина сообщения в сеансах. Зато в большинстве ЛВС скорость передачи датаграмм гораздо выше, чем сообщений в сеансах.</p>
<p>В противоположность датаграммам, в сеансе предполагается создание логической связи для обмена сообщениями между рабочими станциями  и гарантируется получение сообщений. В то время как датаграммы могут передаваться в любые моменты времени, в сеансе для передачи сообщений необходимо выполнить некоторую подготовительную работу: сеанс должен быть сначала установлен, после этого происходит обмен сообщениями, и, наконец, после окончания обмена данными сеанс должен быть закрыт.</p>
<br>
<a name=2 class="anchor"></a>
<h3>4.2. Протоколы IPX/SPX. Протоколы локальных сетей </h3>
<p>Фирма Novell в сетевой ОС NetWare применяет протокол IPX для обмена датаграммами и протокол SPX для обмена в сеансах.</p>
<p>Уровень сеансов связи реализован как надстройка над транспортным уровнем, реализующим датаграммную передачу данных. Соответствие протоколов OSI и NetWare показано на рисунке 4.1.</p>
<p><img src="img/image014.gif"></p>
<p>Рис.4.1. Соответствие протоколов OSI и NetWare</p>
<br>
<p><b>Протокол IPX</b></p>
<p>Протокол IPX (International Packet Exchange – Межсетевой обмен пакетами) применяется модулями перенаправления файлов в ОС NetWare. Протокол IPX является упрощённым вариантом протокола XNS (Xerox Network Standard), разработанного фирмой  Xerox и поддерживает только обмен датаграммами (его иногда называют безсеансным). Он соответствует сетевому уровню по модели OSI и выполняет функции адресации, маршрутизации и переключения в процессе передачи пакетов сообщений. Протокол IPX является более быстродействующим, чем протокол SPX для поддержки сеансов. Несмотря на отсутствие гарантий доставки  сообщений, по данным фирмы Novell, в 95 процентах случаев сообщения доставляются безошибочно.</p>
<p>Именно протокол IPX (а не SPX) используется модулями перенаправления файлов в ОС NetWare при обмене служебными сообщениями с файловым сервером. Этот метод оказывается надёжным потому что каждый такой запрос от рабочей станции требует ответного сообщения со стороны сервера. Таким образом, модули перенаправления файлов подразумевают, что реакция сервера на служебный запрос (например, записать файл) последует только от после соответствующего ответного подтверждения от сервера.</p>
<p>Протокол IPX имеется и во всех версиях NetWare, в отличие от SPX. Пакет IPX можно разделить на две части – заголовок и передаваемые данные (рис.4. 2). В заголовке пакета располагается адрес назначения, обратный адрес и некоторая служебная информация. Особенность формата пакета является то, что все поля заголовка содержат значения в перевёрнутом формате, то есть по младшему адресу записывается старший байт данных, а не младший, как это принято в процессорах фирмы Intel.</p>
<p>Поле “Data” может иметь длину от 0 до 546 байт. Если длина поля “Data” равна нулю, пакет состоит из одного заголовка. Такой пакет может использоваться программой, например, для подтверждения приёма пакета с данными.  </p>
<p><img src="img/image015.gif"></p>
<p>Рис.4.2. Формат пакета IPX</p>
<br>
<p><b>Протокол SPX</b></p>
<p>Протокол SPX (Sequenced Packet Exchange – последовательный обмен пакетами) предназначен для установления диалога и применяется в течение сеанса. Для обмена данными по этому протоколу, прежде всего, необходимо установить логическую связь между двумя участниками диалога. После этого сообщения могут циркулировать в обоих направлениях с гарантией их безошибочной доставки. Протокол SPX также гарантирует, что сообщения будут передаваться в правильной последовательности (в случае одновременной передачи нескольких пакетов). </p>
<p>Протокол SPX работает на транспортном уровне по модели OSI.</p>
<p>В ОС NetWare протокол IPX используется для обмена пакетами, при обслуживании файлов, а протокол SPX используется для доступа к внутренним функциям управления и диагностики сети.</p>
<p>Протокол SPX находится над IPX и использует IPX для обмена пакетами сообщений.</p>
<p><b>Формат пакета SPX </b></p>
<p>Пакет, передаваемый при помощи протокола SPX, имеет более длинный заголовок. Дополнительно к 30 байтам стандартного заголовка пакета IPX добавляется ещё 12 байт (рис. 4. 3).</p>
<p><img src="img/image016.gif"></p>
<p>Рис.4.3. Формат пакета SPX</p>
<br>
<p class=punkt>Поле Coon Control – набор битовых флагов</p>
<p class=punkt>01-08 – зарезервировано;</p>
<p class=punkt>10h – End of Message – признак, сигнализирующий об окончании передачи (формируется программой);</p>
<p class=punkt>20h – Attention – передаётся из программы в программу, игнорируется SPX;</p>
<p class=punkt>40h – Acknowledgement Required – формируется SPX;</p>
<p class=punkt>80h – System Packet – для пакетов, формируемых SPX не для программ.</p>

<p>Поле Data Stream Type – набор битовых флагов, используемый для классификации данных:</p>
<p class=punkt>00h-FDh – может использоваться программой произвольным образом;</p>
<p class=punkt>FEh – End of Connection – формирует SPX по команде из программы;</p>
<p class=punkt>FFh – End of Connection Acknowledgement – Это значение отмечает пакет, подтверждающий завершение связи.
</p>
<br>
<a name=3 class="anchor"></a>
<h3>4.3. Протокол NetBIOS</h3>
<p>Протокол NetBIOS (Network Basic Input/Output System – базовая  сетевая система ввода/вывода), разработан IBM в 1984г. (IBM PC LAN) – LAN Manager. Это протокол работает на трёх уровнях семиуровневой модели OSI: сетевом уровне, транспортном уровне и на уровне каналов связи (рис.4.4).</p>
<p>Протокол NetBIOS поддерживается в сетях IBM (IBM PC LAN), Novell NetWare, Microsoft Windows for Workgroups, UNIX и других сетях. К сожалению, нет единого стандарта на протокол NetBIOS, поэтому в сетевом программном обеспечении разных фирм используются разные интерфейсы для вызова команд NetBIOS.</p>
<p>Наибольший интерфейс представляет применение NetBIOS в сетях Novell NetWare и Microsoft Windows for Workgroups. </p>
<p>NetBIOS является интерфейсом сеансового уровня для LAN Manager (LAN Manager – это сетевая ОС фирмы Microsoft), то есть представляет уровень управления сеансами. В качестве транспортных средств NetBIOS использует транспортные протоколы NetBEUI, TCP/IP или IPX/SPX. Причём родным для LAN Manager (т.е. ОС Microsoft Windows) является NetBEUI – расширенный интерфейс пользователя для сетевой базовой системы ввода-вывода фирмы Microsoft (NetBIOS Extended Uses Interface).</p>
<p><img src="img/image017.gif"></p>
<p>Рис.4.4. Соответствие протоколов OSI и NetWare</p>
<br>
<p>Эти транспортные сетевые средства “сидят” под сеансовым уровнем NetBIOS по отношению к модели OSI.</p>
<p>Программное обеспечение NetBIOS выполняет сетевые функции ввода-вывода в виде команд через интерфейс прикладного программирования (API).</p>
<p>Требования на обмен сообщениями, поступающие от модулей сетевой ОС, выполняющих перенаправление файлов, или от прикладных программ (таких как электронная почта) попадают на уровень NetBIOS. Эти требования можно разделить на четыре категории:</p>
<p class=punkt>1)	Поддержка имён. Каждая из рабочих станций в ЛВС имеет одно или несколько имён. Эти имена хранятся NetBIOS в таблице, в первом столбце которой записывается уникальное и неизменное имя сетевого адаптера. Дополнительные имена пользователей (например, BARRY) могут быть добавлены в таблицу для удобства идентификации каждой рабочей станции. Пользовательские имена могут быть уникальными или, в специальных случаях, относится к группе пользователей.</p>
<p class=punkt>2)	Поддержка сеанса. NetBIOS осуществляет управление процессами установки связи, обмена и окончания связи между любыми двумя узлами (рабочими станциями) в ЛВС. Это происходит следующим образом. Сначала одна станция начинает прослушивать сеть в ожидании вызова. Другая станция её вызывает. Устанавливается сеанс, в течении которого оба компьютера на равных основаниях и принимают сообщения. Закончив, обе станции извещают друг друга об этом и закрывают сеанс.</p>
<p class=punkt>3)	Поддержка датаграмм. Сообщения могут передаваться для какого-то имени, группе имён или всем именам ЛВС. Диалога между двумя машинами при этом не устанавливается и приём сообщений при этом это не гарантируется.</p>
<p class=punkt>4)	Статус адаптера/сеанса. С помощью NetBIOS прикладная программа имеет возможность получить о локальном сетевом адаптере, о других адаптерах в сети и обо всех текущих сеансах в ЛВС.</p>
<p>Фирма IBM поставляла NetBIOS как отдельный программный продукт, реализованный в виде резидентной программы NETBEUI.COM.</p>
<p>Наибольший интерфейс представляет применение NetBIOS в сетях Novell NetWare и Microsoft Windows for Workgroups. </p>
<p><b>Адресация станций и программ</b></p>
<p>В протоколах IPX/SPX для идентификации рабочей станции используются номер сети, адрес станции и сети сокет. Адрес станции определяется на аппаратном уровне и представляет собой число длиной 6 байт. Номер сети занимает 4 байта. Сокеты выделяются динамически драйвером протокола IPX или могут быть получены в Novell. </p>
<p>Протокол NetBIOS использует другой механизм адресации станции и программ. Для адресации станции используются имена размером 16 байт. Каждая станция имеет одно <i>постоянное</i> имя (permanent name), которое образуется из аппаратного адреса добавлением к нему слева десяти нулевых байт. Кроме постоянного имени протокол NetBIOS позволяет добавлять (и удалять) <i>обычные имена и групповые имена</i>.</p>
<p>Обычные имена служат для идентификации рабочей станции, групповые могут служить для посылки пакетов одновременно нескольким станциям в сети. Постоянное имя удалить нельзя, так как оно полностью определяется аппаратным обеспечением станции.</p>
<p>При добавлении обычного имени протокол NetBIOS опрашивает всю сеть для проверки уникального имени. Групповое имя может быть одинаковое на нескольких станциях, поэтому при добавлении группового имени опрос сети не выполняется.</p>
<p>После добавления нового имени  этому имени присваивается так называемый номер имени (name number), который используется для передачи данных по сети.</p>
<p><b>Работа с протоколом NetBIOS</b></p>
<p>Протокол NetBIOS предоставляет программам интерфейс для передачи данных на уровне датаграмм и на уровне каналов связи. Для вызова NetBIOS программа должна создать в памяти управляющий блок, который называется NCB (Network Control Block – сетевой управляющий блок). Адрес заполненного блока NCB передаётся прерыванию. Основные действия при работе с  NetBIOS состоят в следующем:</p>
<p class=punkt>1.	Проверка наличия протокола NetBIOS.</p>
<p class=punkt>2.	Заполнение блока NCB.</p> 
<p class=punkt>3.	Вызов протокола NetBIOS для выполнения команд.</p>
<br>
<a name=4 class="anchor"></a>
<h3>4.4. Семейство протоколов TCP/IP </h3>
<p>Протокол TCP/IP (Transmission Control Protocol / Internet Protocol) сходен с NetBIOS, IPX и SPX в различных отношениях. Протокол TCP/IP разрабатывался Министерством Обороны США для глобальной (а не локальной) сети ARPANET, предназначенной для связи территориально разнесённых организаций, работавший в рамках ARPA (Advanced Research Project Agency – агентство по передовым исследовательским проектам). Протокол TCP/IP является набором протоколов, а не сетевой ОС. Часть этого набора IP обеспечивает обмен датаграммами между узлами сети (подобно IPX). Протокол TCP (подобно NetBIOS) обеспечивает связь между двумя узлами с гарантированной доставкой сообщений. На базе этого протокола построены ряд стандартных утилит: для передачи файлов (FTP), для дистанционного запуска программ (TELNET) и для обмена электронной почтой (SMTP).</p>
<p>Термин “TCP/IP” охватывает целое семейство протоколов, прикладные программы и даже саму сеть. TCP/IP – это технология множественного взаимодействия, технология “internet”. В состав семейства входят протоколы UDP, ARP, TELNET, FTP и многие другие. Эти протоколы были разработаны для обеспечения требований глобальной сети Internet.</p>
<p>Логическая структура сетевого программного обеспечения, реализующего протоколы семейства TCP/IP в каждом узле сети Internet показана на рисунке 4.5.</p>
<p><img src="img/image018.gif"></p>
<p>Рис.4.5. Архитектура TCP/IP</p>
<br>
<p>Переданные данные имеют следующие названия:</p>
<p class=punkt><i>Кадр</i> – блок данных, переданных сетевым адаптером.</p>
<p class=punkt><i>Пакет</i> – блок данных между драйвером и модулем IP.</p>
<p class=punkt><i>TCP-сегмент</i> – блок данных между IP и модулем TCP.</p>
<p class=punkt><i>Датаграмма </i>– блок данных между TCP и UDP.</p>
<p class=punkt><i>Прикладное сообщение</i> – блок данных находится  на уровне прикладных процессов.</p>
<p>При разработке протоколов TCP приняты четыре уровня:</p>
<p class=punkt>•	Уровень приложений – обеспечение прикладных услуг: удалённый доступ, почта, … (Telnet, FTP, SMTP и др.);</p>
<p class=punkt>•	транспортный уровень – передача данных между процессами;</p>
<p class=punkt>•	уровень Internet – передача данных между хостами, маршрутизация;</p>
<p class=punkt>•	уровень сетевого интерфейса – доступ к физической сети.</p>
<p>Отображение архитектуры TCP/IP на модель OSI показано на рисунке 4.6.</p>
<p><img src="img/image019.gif"></p>
<p>Рис. 4.6. Соответствие архитектуры TCP/IP и модели OSI</p>
<br>
<p><b>Протокол IP</b></p>
<p>Межсетевой протокол (Internet Protocol, IP) обеспечивает доставку фрагмента данных (датаграммы) от источника к получателю. В протоколе IP отсутствуют функции подтверждения, контроля передачи, сохранения последовательности передаваемых датаграмм и т.д.</p>
<p>В рамках модели OSI протокол IP занимает третий уровень – сетевой и  выполняет три основные функции: адресацию, фрагментацию и маршрутизацию данных.</p>
<p>Данные, формат которых понятен протоколу IP, носят название датаграммы (пакет). Датаграмма состоит из заголовка, содержащего необходимую управляющую информацию для модуля IP, и данных, которые передаются от протоколов верхних уровней и формат которых известен IP. </p>
<p>Формат IP-датаграммы (пакета) показан на рисунке 4.7:</p>
<p><img src="img/image020.gif"></p>
<p>Рис.4.7. Формат IP-датаграммы</p>
<br>
<p>Протокол IP обрабатывает каждую датаграмму как самостоятельный объект, независящий от других передаваемых датаграмм.</p>
<p>Маршрутизация производится на основе адреса, расположенного в заголовке IP-датаграммы.</p>
<p>Фрагментация необходима, так как путь датаграммы может проходить через сети с различной топологией (например, Ethernet – 1500, FDDI – 4700 байт и др.).</p>
<p>Заголовок IP-датаграммы имеют формат, показанный на рисунке 4.8.</p>
<p><img src="img/image021.gif"></p>
<p>Рис.4.8. Заголовок IP-датаграммы</p>
<br>
<p>Описание полей заголовка:</p>
<p>Version – определяет версию протокола.</p>
<p>IHL (Internet header length) – длина заголовка в 32 байтных словах, при минимальной длине заголовка = 5</p>
<p>Type of Service – характеристики обработки датаграммы</p>
<p class=punkt>•	Биты 0-2 – приоритет (Precedence)</p>
<p class=punkt>•	Бит 3 – задержка (Delay). 0 – нормальная, 1 – низкое значение</p>
<p class=punkt>•	Бит 4 – скорость передачи (Throughput) 0 – нормальная, 1 – высокая</p>
<p class=punkt>•	Бит 5 – надёжность (Relaibi city ) 0 – нормальная , 1 – высокая</p>
<p>Total Length – общий размер датаграммы ≤ 65535 байт.</p>
<p>Identification – уникальное значение фрагмента датаграммы</p>
<p>Flags:</p>
<p class=punkt>•	Бит – 0 (зарезервирован);</p>
<p class=punkt>•	Бит – 1 (0 – разрешена фрагментация, 1 – запрещена фрагментация);</p>
<p class=punkt>•	Бит – 2 (0 – последний фрагмент в датаграмме, 1- не последний фрагмент).</p>
<p>Fragment Offset – положение фрагмента в объединённой датаграмме. На приёме объединяются датаграммы с  одинаковыми четырьмя полями: </p><p>Identification, Source Address, Destination Address и Protocol.</p> 	   
<p>TTL (Time to Live) – время жизни датаграммы, если это поле = 0, то датаграмма уничтожается. При каждом проходе шлюза TTL= TTL-1.</p> <p>Смысл – исключить засорения сети “засорившимися” датаграммами.</p>
<p>Protocol – определяет номер верхнего уровня, которому предназначена датаграмма:</p>
<p class=punkt>1  Internet Control Message Protocol, ICMP;</p>
<p class=punkt>2  Internet Group Management Protocol, IGMP;</p>
<p class=punkt>4  Инкапсуляция IP в IP;</p>
<p class=punkt>6  Transmission Control Protocol, TCP;</p>
<p class=punkt>17  Uses Datagram Protocol, UDP;</p>
<p>Source Address – адреса сетевого уровня или IP-адреса </p>
<p>Destination Address – адреса сетевого уровня или IP-адреса </p>
<p>Option – различные опции протокола</p>
<p>Padding – служит для выравнивания до границы 32-битного слова.</p>
<p><b>IP- адрес</b></p>
<p>Каждый IP-адрес можно представить состоящим из двух частей: адреса сети и адреса хоста.</p>
<p>Существуют пять возможных форматов – классов адресов.</p>
<p>Класс адреса определяется значением его первого байта:</p>
<p><img src="img/image022.gif"></p>
<p>В настоящие время выделяются сети класса C. Сетей такого класса может быть 2097150, а число хостов не более 254. Адреса IP принято записывать в виде четырёх десятичных чисел, разделённых точкой (например: 193.221.33.117).</p>
<p><b>Маска IP- адреса</b></p>
<p>Для более эффективного использования адресного пространства введено понятие <i>подсетей</i>. IP-адрес хоста делится на две составляющие:</p>
<p>-	адрес подсети; </p>
<p>-	адрес хоста. </p>
<p>Размер подсети определяется маской – 4-х байтным словом, маскирующим адрес единицами (в двойной форме). </p>
<p>Чтобы получить адрес сети, зная IP-адрес и маску подсети, необходимо применить к ним операцию поразрядной конъюнкции (логическое И). Например, рассмотрим:</p>
<p>IP-адрес:       11000001 11011101 00100001 01110101 (193.221.33.117)</p>
<p>Маска подсети:  11111111 11111111 11111111 11110000 (255.255.255.000)</p>
<p>Получим </p>
<p>Адрес сети:     11000001 11011101 00100001 00000000 (193.221.33.0)</p>
<p>В такой сети 255 адресов машин. И, как правило, они видят друг друга в сети. Кроме того, если все машины располагаются на разных территориях или относятся к разным учереждениям, то возникает сложность и с маршрутизацией. Такую сеть удобно разбить на несколько подстей. Установим маску 255.255.255.224. Последний байт имеет двоичную кодировку 11100000. Количество единиц равное трем указывает, что сеть разбита на 23=8 подсетей. Последующее число нулей определит число машин в каждой подсети равное 25=32. </p>
<p>IP-адрес:       11000001 11011101 00100001 01110101 (193.221.33.117)</p>
<p>Маска подсети:  11111111 11111111 11111111 1110000 (255.255.255.240)</p>
<p>Наша машина будет находиться в подсети с адресом:</p>
<p>11000001 11011101 00100001 01110000 (193.221.33.112)и соответственно, адрес шлюза для нее 193.221.33.113</p>
<p>Маску подсети записывают вместе с IP-адресом в формате «IP-адрес/количество единичных бит в маске». Число после слэша означает количество единичных разрядов в маске подсети.</p>
<p>Рассмотрим пример записи диапазона IP-адресов в виде 10.96.0.0/11. В этом случае маска подсети будет иметь двоичный вид 11111111 11100000 00000000 00000000, или то же самое в десятичном виде: 255.224.0.0. 11 разрядов IP-адреса отводятся под номер сети, а остальные 32 – 11 = 21 разряд полного адреса — под локальный адрес в этой сети. Итого, 10.96.0.0/11 означает диапазон адресов от 10.96.0.1 до 10.127.255.254.</p>
<p>Выделены несколько групп адресов для специальных нужд:</p>
<p>0.0.0.0 – данный адрес предназначен для передачи пакетов самому себе;</p>
<p>127.0.0.0/8 – сеть обратная петля (loopback). Эта сеть предназначена для тестирования сетевых приложений. Адрес 127.0.0.1 используется для адресации к самому себе. Пакеты, отправляемые на адреса из этой сети не уходят в реальную сеть, а принимаются в на этих же машинах</p>
<p>224.0.0.0/4 – групповые адреса.</p>
<p>10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16 – адреса приватных сетей. Такие адреса не имеют права встречаться в публичном Интернет. Подобные адреса можно назначать для множества локальных сетей, так как шлюз в публичную сеть их не выпустит. Пользователи сетей с такими адресами осуществляют доступ к ресурсам сети через прокси или внутри протокольные шлюзы. </p>
<p><b>Протокол транспортного уровня TCP</b></p>
<p>Протокол TCP  является протоколом четвёртого уровня в рамках модели OSI.</p>
<p>На базе протокола TCP реализованы такие протоколы уровня приложений, как Telnet, FTP, HTTP и др.</p>
<p>Протокол характеризуется следующими возможностями:</p>
<p>-	установление связи и завершение после сеанса;</p>
<p>-	гарантированная доставка;</p>
<p>-	доставка электронных данных.
</p>
<p>TCP-канал представляет собой двунаправленный поток данных. В виде пакетов различной длины – сегментов.</p>
<p> Сегмент состоит из заголовка и данных(рис.4.9).</p>
<p><img src="img/image023.gif"></p>
<p>Рис.4.9. Код заголовка TCP – сегмента:</p>
<br>
<p>В заголовке TCP поля имеют следующие значения:</p>
<p><i>Offset</i> – указывает начало данных сегмента. Min значение = 5.
<p><i>Sequence Number</i> – положение каждого сегмента в потоке, то есть</p> порядковый номер первого байта сегмента в потоке.</p>
<p><i>Acknowledgement Number</i> – ответ о количестве полученных последовательностей соответствует номеру первого ожидаемого байта сегмента в потоке.</p>
<p><i>Flags</i> – URG, ACK, PSH, RST, SYN, FIN </p>
<p><i>Window</i> – указывает передающему количество сегментов которые адресат готов принять до приёма подтверждения.</p>
<p><i>Urgent Pointer </i>– указатель положения экстренных данных внутри данных.</p>
<p><i>Options</i> – переменной длины, содержит различные опции, например, максимальный размер сегмента MMS.</p>
<p><i>Padding</i> – нулями добавляет массив до кратности 32-х разрядов.</p>
<p><b>Состояние TCP-сеанса. </b></p>
<p>Взаимодействие в TCP производится в 3 фазы (рис.4.10):</p>
<p>1.	Начальная фаза – “тройное рукопожатие” (three-way handshake). Клиент посылает бит – SYN=1. Сервер установил логический канал и посылает биты SYN и ACK. Клиент посылает ACK подтверждение получения разрешения. </p>
<p>2.	Фаза передачи. Обе стороны начинают передавать, номер TCP-сегментов с флагом ACK, подтверждающим получение ответа от сервера. Если нет подтверждения после определённого времени, то TCP – сегменты повторяются начиная с последнего подтверждённого. </p>
<p>3.	Фаза завершения – любая из сторон передаёт TCP-сегмент с сигналом FIN. После получения подтверждения связь прерывается.</p>
<p>Каждый передаваемый сегмент хранит в заголовке номер первого байта данных в заданной пропорции. Например, если размер пакета равен 200 байт, то номера первых байтов будут ¬ 1, 201, 401 и т.д. Порядковый номер передаваемого первого байта и номер подтверждения играют ключевую роль в обеспечении надёжности доставки. TCP – является протоколом с позитивным подтверждением и повторной передачей (Positive Acknowledgment and Retransmission, PAR).</p>
<p>Если данные доставлены без ошибок, получатель подтверждает это флагом ACK. Если отправитель не получает подтверждение в течении некоторого времени, он повторно передаёт данные. В любом случае отсутствует негативное подтверждение NAK</p>
<p><img src="img/image024.gif"></p>
<p>Рис.4.10. Фазы взаимодействия в TCP</p>
<br>
<a name=5 class="anchor"></a>
<h3>4.5. Протокол UDP  </h3>
<p>UDP (User Data Protocol) является протоколом транспортного уровня и обеспечивает логический коммуникационный канал между источником и получателем данных без предварительного установление связи.</p>
<p>Для передачи датаграмм UDP использует протокол IP.  Не обеспечивает надёжности передачи. Поэтому приложения, использующие этот транспортный протокол должны при необходимости самостоятельно обеспечивать надёжность обмена, например, путём обмена подтверждениями повторной передачей не доставленных сообщений. </p>
<p>Благодаря минимальной функциональности  протокола UDP, передача данных сего использованием вносит гораздо меньшие накладные расходы по сравнению, скажем, с парным ему транспортным протоколом TCP. Размер заголовка UDP составляет всего 8 байт:</p>
<p><img src="img/image025.gif"></p>
<p>Source Port – указание порта источника является необязательным и это поле может быть заполнено нулями.</p>
<p>Length – длина датаграммы ≥ 8.</p>
<p>Checksum – заполняется, если протокол верхнего уровня требует этого, иначе нулями.</p>
<p>UDP – заголовок предваряется IP- псевдо заголовком, содержащим IP-адрес источника и получателя и поле Protocol.
</p><p><img src="img/image026.gif"></p>
<p>В качестве примеров протокола уровня приложений, которые используют в качестве транспорта протокол UDP, можно привести:</p>
<p>-	Протокол взаимодействия с сервером доменных имён DNS, порт 53.</p>
<p>-	Протокол синхронизации времени Network Time Protocol, порт 123.</p>
<p>-	Протокол удалённой загрузки BOOT, порты 67 и 68 клиента и сервера соответственно.</p>
<p>-	Протокол удалённого копирования Trivial FTP, порт 69.</p>
<p>-	Удалённый вызов процедур RPC, порт 111.
</p>

<br><br>
<!--конец-->
      
				

				</div>
			</div>
			
      </div>
    </div>
  </div>
	
	<!--Меню навигации по Темам -->	
	<div aria-label="..." class = "nav-menu">
	 <ul class="pager background-transition-slow">
		 <li title="Наверх" style = "margin-right:15px;	"><a class = "glyphicon glyphicon-menu-up page-scroll" href="#page-top"></a></li>
		 <li title="К предыдущей лекции"><a class = "glyphicon glyphicon-menu-left page-scroll" href="lec3.htm"></a></li>
		 <li title="В содержание"><a class = "glyphicon glyphicon-list-alt" href="lec_index.htm"></a></li>
		 <li title="К следующей лекции"><a class = "glyphicon glyphicon-menu-right page-scroll" href="lec5.htm"></a></li>
	 </ul>
	</div>
	<!---->
	
	</div>
  <!-- jQuery -->
  <script src="../lib/js/jquery.js"></script>

  <!-- Bootstrap Core JavaScript -->
  <script src="../lib/js/bootstrap.min.js"></script>

  <!-- Scrolling Nav JavaScript -->
  <script src="../lib/js/jquery.easing.min.js"></script>
  <script src="../lib/js/scrolling-nav.js"></script>

</body>

</html>
